I"E<h2 id="一基本概念">一、基本概念</h2>

<p>树其实是一种递归性质的数据结构</p>

<h3 id="1概念">1.概念</h3>

<p>根节点、边、分支结点、叶子结点</p>

<p>空树：结点数为0的树</p>

<p>非空树：至少有且仅有一个根节点</p>

<p>无后继的结点为<strong>叶子结点</strong>（终端结点）</p>

<p>有后继的结点为<strong>分支结点</strong>（非终端结点）</p>

<p>除了根结点外，任何一个结点都<strong>有且仅有一个前驱</strong></p>

<p>根节点的子树</p>

<h3 id="2术语">2.术语</h3>

<p>路径，只能从上往下</p>

<p>路径长度：经过几条边</p>

<p>属性：</p>

<ul>
  <li>结点的层次（深度）：从上往下数。默认从1开始，有些会从当成0开始</li>
  <li>结点的高度：从下往上数</li>
  <li>树的高度（深度）：总共多少层</li>
  <li>结点的度：该结点几个孩子（分支）</li>
  <li>树的度：结点的度的最大值</li>
</ul>

<p>有序树：逻辑上看，树中结点的各子树从左至右是<strong>有</strong>次序的，<strong>不能</strong>互换</p>

<p>无序树：逻辑上看，树中结点的各子树从左至右是<strong>无</strong>次序的，<strong>可以</strong>互换</p>

<p>森林：是m（m&gt;0）棵互不相交的树的集合</p>

<p>考点：森林和树相互转换的问题</p>

<h3 id="3性质">3.性质</h3>

<ul>
  <li>
    <p>结点数 = 总度数 + 1</p>
  </li>
  <li>
    <p>度为m的树、m叉树的区别</p>

    <ul>
      <li>
        <p>度为m的树</p>

        <ul>
          <li>任意结点的度≤m（最多m个孩子）</li>
          <li>至少有一个结点度为m（有m个孩子）</li>
          <li>一定是非空树，至少有m+1个结点</li>
          <li>第i层至多有m<sup>i-1</sup>个结点（i ≥ 1）</li>
          <li>高度为h的度为m的树至少有h+m-1个结点</li>
        </ul>
      </li>
      <li>
        <p>m叉树</p>

        <ul>
          <li>
            <p>任意结点的度≤m（最多m个孩子）</p>
          </li>
          <li>
            <p>允许所有结点的度都 &lt; m</p>
          </li>
          <li>
            <p>可以是空树</p>
          </li>
          <li>
            <p>第i层至多有m<sup>i-1</sup>个结点（i ≥ 1）</p>
          </li>
          <li>
            <p>高度为h的m叉树至多有$\frac{m^h-1}{m-1}$个结点</p>
          </li>
          <li>
            <p>高度为h的m叉树至少有h个结点</p>
          </li>
          <li>
            <p>n个结点的m叉树的最小高度为 log<sub>m</sub>(n(m-1)+1)</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="4存储">4.存储</h3>

<p><strong>双亲表示法（顺序存储）</strong>：每个结点中保存指向双亲的指针</p>

<p><img src="https://img.kanzhun.com/images/seo/mianshiti/20191125/d791eda7f60053a6ffe2b2ccb27fa94b.jpg" alt="" /></p>

<p>根结点固定存放在0，-1表示没有双亲</p>

<ul>
  <li>优点：查指定结点的双亲很方便</li>
  <li>缺点：查指定结点的孩子只能从头遍历</li>
</ul>

<p><strong>孩子表示法（顺序+链式存储）</strong>：顺序存储各个节点，每个结点中保存孩子链表头指针</p>

<p><img src="https://gitee.com/yangyuanhuyyh/MDimage/raw/master/uPic/image-20200610100421170.png" alt="" /></p>

<p><strong>孩子兄弟表示法（链式存储）</strong>：左指针指向孩子，右指针指向兄弟</p>

<p><img src="https://gitee.com/yangyuanhuyyh/MDimage/raw/master/uPic/image-20200610104528702.png" alt="" /></p>

<p>其实这就是树转二叉树</p>

<p>树转二叉树，<strong>根结点的右子树总是空的</strong></p>

<p><strong>森林和二叉树的转换</strong></p>

<p>森林是m（m ≥ 0）棵互不相交的树的集合</p>

<p><img src="https://upload-images.jianshu.io/upload_images/6567790-f8a7032a2a1ea55d.png" alt="" /></p>

<p>先把三棵树转成二叉树</p>

<p>再把A看成根节点，D、G看出A的兄弟结点，再按照孩子兄弟表示法转换成二叉树</p>

<h2 id="二二叉树">二、二叉树</h2>

<p>特点：</p>

<ul>
  <li>每个结点至多只有两颗子树</li>
  <li>左右子树不能颠倒（二叉树是有序树）</li>
</ul>

<p>n个结点的二叉树有$\frac {C_{2n}^{n}}{n+1}$种形态</p>

<h3 id="1特殊二叉树">1.特殊二叉树</h3>

<p><strong>满二叉树</strong>：一颗高度为h，且具有2<sup>h</sup> - 1个结点的二叉树</p>

<p><img src="http://image.mamicode.com/info/202007/20200705174025362527.png" alt="满二叉树" /></p>

<p>特点：</p>

<ol>
  <li>只有最后一层有叶子结点</li>
  <li>不存在度为1的结点</li>
  <li>按层序从1开始编号
    <ul>
      <li>结点i的左孩子为2i，有孩子为2i+1</li>
      <li>结点i的父节点为$\lfloor i/2 \rfloor$（假如有的话）</li>
    </ul>
  </li>
</ol>

<p><strong>完全二叉树</strong>：当且仅当其每个结点都与高度为h的满二叉树中编号1~n的结点一一对应时，称为完全二叉树</p>

<p><img src="http://image1.bubuko.com/info/202007/20200702002547976538.png" alt="完全二叉树" /></p>

<p>所以满二叉树就是一种特殊的完全二叉树</p>

<p>特点：</p>

<ol>
  <li>只有最后两层可能有叶子结点</li>
  <li>最多只有一个度为1的结点</li>
  <li>同上3</li>
  <li>i ≤ $\lfloor n/2 \rfloor$为分支结点，i &gt;$\lfloor n/2 \rfloor$为叶子结点</li>
</ol>

<p>如果完全二叉树的某结点只有一个孩子，那么一定是左孩子</p>

<p><strong>二叉排序树（BST）</strong></p>

<p>左子树上所有结点的关键字均<strong>小</strong>于根节点的关键字</p>

<p>左子树上所有结点的关键字均<strong>大</strong>于根节点的关键字</p>

<p>即：左子树结点值 &lt; 根节点值 &lt; 右子树结点值</p>

<p>左子树和右子树又各是一棵二叉排序树</p>

<p><img src="https://upload-images.jianshu.io/upload_images/8897049-856881d6ab38ecbb.jpg" alt="二叉排序树" /></p>

<p>对其进行中序遍历，可以得到一个递增的有序序列</p>

<p>二叉排序树可用于元素的有序组织、搜索</p>

<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fupload-images.jianshu.io%2Fupload_images%2F13944677-7d803e184085115a.gif&amp;refer=http%3A%2F%2Fupload-images.jianshu.io&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1626421582&amp;t=c309331f53d13d2c160790754ee452e1" alt="" /></p>

<p>新插入的结点一定是叶子结点</p>

<p>二叉排序树越不平衡，效率就越低，所以需要提到平衡二叉树来解决</p>

<p><strong>平衡二叉树（BBT）</strong></p>

<p>简称平衡树（AVL树）</p>

<p>树上任一结点的左子树和右子树的<strong>深度之差</strong>不超过1</p>

<p>结点的平衡因子 = 左子树高度 - 右子树高度</p>

<p>平衡二叉树结点的平衡因子的值只可能是-1、0和1</p>

<p><img src="https://pic1.zhimg.com/v2-3641cb45e889c1d344e9164c95a0644f_1440w.jpg" alt="平衡二叉树" /></p>

<p>为什么要有平衡二叉树？</p>

<p>因为二叉树有可能退化为单链表，这时候作为树就没有意义</p>

<p><img src="https://img2018.cnblogs.com/blog/578453/201909/578453-20190927102318864-485895958.png" alt="" /></p>

<p>平衡二叉树能有更高的搜索效率</p>

<p>二叉排序树加入平衡因子，然后调整成为二叉平衡排序树</p>

<p><img src="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=230391890,913215039&amp;fm=26&amp;gp=0.jpg" alt="" /></p>

<p>只调整的地方叫做<strong>最小不平衡子树</strong></p>

<p>所以接下来就是如何调整的方法</p>

<ul>
  <li>
    <p>LL（右单旋转）：在A的<strong>左</strong>孩子的<strong>左</strong>子树中插入导致不平衡</p>

    <p><img src="https://img2018.cnblogs.com/blog/578453/201909/578453-20190927103444205-176846244.gif" alt="" /></p>
  </li>
  <li>
    <p>RR（左单旋转）：在A的<strong>右</strong>孩子的<strong>右</strong>子树中插入导致不平衡</p>

    <p><img src="https://img2018.cnblogs.com/blog/578453/201909/578453-20190927103554968-1963499271.gif" alt="" /></p>
  </li>
  <li>
    <p>LR（先左后右双旋转）：在A的<strong>左</strong>孩子的<strong>右</strong>子树中插入导致不平衡</p>

    <ul>
      <li>A的左孩子的右孩子先左上旋再右上旋</li>
    </ul>
  </li>
  <li>
    <p>RL（先右后左双旋转）：在A的<strong>右</strong>孩子的<strong>左</strong>子树中插入导致不平衡</p>

    <ul>
      <li>A的右孩子的左孩子先右上旋再左上旋</li>
    </ul>
  </li>
</ul>

<p><strong>哈夫曼树</strong></p>

<p>树的带权路径长度（WPL，Weighted Path Length）：树中所有叶子节点的带权路径长度之和</p>

<p>其中n个带权叶结点的二叉树中，其中WPL最小的二叉树称为<strong>哈夫曼树</strong>，也叫<strong>最优二叉树</strong></p>

<p><img src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=3158860133,3677539387&amp;fm=26&amp;gp=0.jpg" alt="" /></p>

<p>哈夫曼树的构造</p>

<ol>
  <li>每次选择两个最小权值的结点两两结合，然后把这两个结点结合的根作为新的结点，权值为两个最小权值的和</li>
  <li>重复第一步</li>
</ol>

<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.pianshen.com%2Fimages%2F490%2Ff68b27885d47d7d72e152902967b9f4a.gif&amp;refer=http%3A%2F%2Fwww.pianshen.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1626423761&amp;t=8b6eec1b38c33c76876ff5343a8c8cfa" alt="" /></p>

<ul>
  <li>哈夫曼树中不存在度为1的结点</li>
  <li>哈夫曼树并不唯一，但WPL必然相同且为最优</li>
  <li>n个结点构造的哈夫曼树最后的结点总数为2n-1</li>
  <li>左右顺序任意</li>
</ul>

<p>哈夫曼编码</p>

<p>就是边也有权值，只是权值是左边0，右边1</p>

<p>是一种前缀编码</p>

<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.it610.com%2Fimage%2Fproduct%2Fc490fd4e561446d6939fc7b57ae4ca68.png&amp;refer=http%3A%2F%2Fimg.it610.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1626424505&amp;t=35a84161490cf82a960990823317a74f" alt="" /></p>

<h3 id="2常考性质">2.常考性质</h3>

<p><strong>二叉树常考性质</strong></p>

<ol>
  <li>设非空二叉树中度为0、1、2的结点个数分别为n<sub>0</sub>、n<sub>1</sub>和n<sub>2</sub>，则<strong>n<sub>0</sub> = n<sub>2</sub> + 1</strong>（叶子结点比二分支结点多一个）</li>
  <li>二叉树<strong>第i层</strong>至<strong>多</strong>有<strong>2<sup>i-1</sup>个结点</strong>（i≥1）
    <ul>
      <li>m叉树第i层至多有m<sup>i-1</sup>个结点（i≥1）</li>
    </ul>
  </li>
  <li>高度为<strong>h</strong>的二叉树至<strong>多</strong>有<strong>2<sup>h-1</sup>个结点</strong>（也就是满二叉树）
    <ul>
      <li>高度为h的m叉树至多有$\frac{m^h-1}{m-1}$个结点</li>
    </ul>
  </li>
</ol>

<p><strong>完全二叉树常考性质</strong></p>

<ol>
  <li>具有n个（n&gt;0）结点的完全二叉树的高度h为<strong>$\lceil \log_2(n+1) \rceil$</strong> 或 <strong>$\lfloor \log_2n + 1\rfloor$</strong></li>
  <li>对于完全二叉树，可以由结点数n推出度为0、1和2的结点个数为n<sub>0</sub>、n<sub>1</sub>和n<sub>2</sub>
    <ul>
      <li>若完全二叉树有2k个（偶数）结点，则必有n<sub>1</sub> = 1，n<sub>0</sub> = k，n<sub>2</sub> = k - 1</li>
      <li>若完全二叉树有2k-1个（奇数）结点，则必有n<sub>1</sub> = 0，n<sub>0</sub> = k，n<sub>2</sub> = k - 1</li>
    </ul>
  </li>
  <li>深度为k的完全二叉树至少有2<sup>k-1</sup>个结点，至多有2<sup>k</sup> - 1个结点</li>
</ol>

<h3 id="3存储结构">3.存储结构</h3>

<p>几个重要常考的基本操作</p>

<ul>
  <li>i 的左/右孩子：2i/2i + 1</li>
  <li>i 的父节点：$\lfloor i/2\rfloor$</li>
  <li>i所在的层次：$\lceil \log_2(n+1) \rceil$</li>
</ul>

<p>若完全二叉树中共有n个结点，则</p>

<ul>
  <li>判断i是否有左/右孩子：2i/2i + 1 ≤ n</li>
  <li>判断i是否是叶子/分支结点：i &gt; $\lfloor n/2\rfloor$</li>
</ul>

<p><strong>顺序存储</strong></p>

<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg.it610.com%2Fimage%2Finfo5%2F6920dd95659e4d85964a2b2c4578ef79.jpg&amp;refer=http%3A%2F%2Fimg.it610.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1626331086&amp;t=0ac3e75d53d9c2a96bb5d5b19d7902a8" alt="顺序存储" /></p>

<p>顺序存储的二叉树会浪费很多空间</p>

<p>寻找结点的最坏情况：</p>

<p>高度为h且只有h个结点的单支树（所有结点只有右孩子），也至少需要2<sup>h</sup> - 1个存储单元</p>

<p>假如一定要用顺序存储二叉树，一定要把二叉树的结点编号与完全二叉树对应起来，这样上述判断才能起作用</p>

<p>结论：二叉树的顺序存储结构，只适合存储完全二叉树</p>

<p><strong>链式存储</strong></p>

<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimage.mamicode.com%2Finfo%2F201801%2F20180120183527333756.png&amp;refer=http%3A%2F%2Fimage.mamicode.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1626331670&amp;t=e110c92b12091d856d8880226c325a4f" alt="链式存储" /></p>

<p>n个结点的二叉链表有n+1个空链表（可用于构造线索二叉树）</p>

<p>这样找孩子很方便，但是找父亲要重头开始遍历，假如数据少还好，数据多的时候就很不方便了</p>

<p>这时候再加个指针指向父结点，就是三叉链表</p>

<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic002.cnblogs.com%2Fimages%2F2012%2F331765%2F2012031419200953.png&amp;refer=http%3A%2F%2Fpic002.cnblogs.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1626331890&amp;t=535e53e5f32cb0754636ff2a13a1bbd7" alt="三叉链表" /></p>

<p>方便找父结点</p>

<p>可根据实际需求决定要不要加父结点指针</p>

<p><strong>双亲表示法</strong></p>

<p>每个结点中保存指向双亲的指针</p>

<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fzcdll.github.io%2Fimages%2Fparent-tree.png&amp;refer=http%3A%2F%2Fzcdll.github.io&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1626336093&amp;t=bf405b48c632b20e8d93dc977bf1a101" alt="双亲表示法" /></p>

<h3 id="4遍历">4.遍历</h3>

<p>先根：<strong>根</strong>左右（树/森林的<strong>先根</strong>遍历和树/森林转二叉树的<strong>先根</strong>遍历的结果是一样的）</p>

<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic4.zhimg.com%2Fv2-9db573561b49f6929d7612262f0954af_b.gif&amp;refer=http%3A%2F%2Fpic4.zhimg.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1626422311&amp;t=85671b5d4bb63044443a6d4cee09d862" alt="" /></p>

<p>中根：左<strong>根</strong>右（森林的<strong>中根</strong>遍历和森林转二叉树的<strong>中根</strong>遍历的结果是一样的）</p>

<p><img src="https://pic3.zhimg.com/v2-97f2e02b5bad3679931dfca8275a6a52_b.webp" alt="" /></p>

<p>后根：左右<strong>根</strong>（树的<strong>后根</strong>遍历和树转二叉树的<strong>中根</strong>遍历的结果是一样的）</p>

<p><img src="https://pic3.zhimg.com/v2-9250fccf446cf06d42dd73296e48d0be_b.webp" alt="" /></p>

<p>层次遍历</p>

<p><img src="https://pic4.zhimg.com/v2-0927ca68e27ca9fd6978cd6cecf4436f_b.webp" alt="层次遍历" /></p>

<p><strong>由遍历序列构造二叉树</strong></p>

<p>若只给出一个前/中/后/层序遍历序列，不能确定一颗二叉树</p>

<p>所以遍历序列需要至少两种序列才能构造二叉树：</p>

<ul>
  <li>前 + 中</li>
  <li>后 + 中</li>
  <li>层 + 中</li>
</ul>

<p>重点：找到树的根节点，并根据中序序列划分左右子树，再找到左右子树，再找到左右子树根节点，重复操作即可</p>

<p>注意：</p>

<ul>
  <li>前序、后序、层序的两两组合无法唯一确定一棵二叉树</li>
  <li>一个树的叶结点,在前序遍历和后序遍历下,皆以相同的相对位置出现</li>
</ul>

<h3 id="5线索二叉树">5.线索二叉树</h3>

<p>就是利用序列，将空的指针利用起来</p>

<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimage.mamicode.com%2Finfo%2F201911%2F20191118165525934117.png&amp;refer=http%3A%2F%2Fimage.mamicode.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1626333791&amp;t=387ba46270aa09eb7a456e0122ff6634" alt="线索二叉树" /></p>

<p>作用：方便从一个指定结点出发，找到其前驱、后继；方便遍历</p>

<p>指向前驱/后继的指针称为线索</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center">中序线索二叉树</th>
      <th style="text-align: center">先序线索二叉树</th>
      <th style="text-align: center">后序线索二叉树</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">找前驱</td>
      <td style="text-align: center">√</td>
      <td style="text-align: center">×</td>
      <td style="text-align: center">√</td>
    </tr>
    <tr>
      <td style="text-align: center">找后继</td>
      <td style="text-align: center">√</td>
      <td style="text-align: center">√</td>
      <td style="text-align: center">×</td>
    </tr>
  </tbody>
</table>

:ET