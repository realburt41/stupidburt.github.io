---
layout:     post
title:      "年轻人第一个PBR（一）"
subtitle:   "造轮子时间！"
date:       2021-7-2
author:     "Burt"
header-style: text 
tags:
    - PBR
    - Shader
---



## 前言

只要是做渲染的，应该没有人没听过pbr吧



## 一、啰哩吧嗦

好处是：

1. 表达能力强(一个shader能通过调节表达过去十几几十个shader的效果)
2. 美术参数减少
3. 参数基于物理，美术程序更好理解
4. 制定统一的美术标准（即标准化）
5. 光照和材质解耦，艺术家可以不用关注贴图上如何呈现光照质感，只专注于材质本身



**实际上的“PB”在实时渲染并不完全是Physically Based**，只是一种近似



PBR材质有两个方面

- 表面：相对容易实现，大部分用于微平面理论和迪士尼BRDF
- 体积：相对更难实现，关注快速、近似的单次散射和多次散射，例如云，皮肤，头发等



这里我们只讲表面



还有关于什么辐射量之类的我实在是看不懂，等以后大佬带带我吧



## 二、PBR核心理论

- 微平面理论：DG项
- 能量守恒：出射光 <= 入射光（自发光除外）。粗糙度相关
- 菲涅尔反射：F项
- 线性空间与伽马矫正
- 色调映射：HDR转LDR，一般在后处理ACES
- 物质的光学特性：金属与非金属



## 三、代码实现

我这次用偷懒版金属流，没有考虑GI，之后会总结高光流和金属流的优缺点（抄就完事了）

首先是PBR框架

- 直接漫反射：迪士尼漫反射
- 直接镜面反射：DGF项和掠射角系数
- 间接漫反射：球谐或lightmap
- 间接镜面反射：全局反射探针



前两个是光直接照射到产生的颜色

后两个是从别的物体或者环境弹射到产生的颜色



贴图参数则是标配

- albedo贴图
- 法线贴图
- 金属度贴图：区分金属与非金属
- 粗糙度贴图
- AO贴图

其实后三个可以合并成一张图，都是单通道信息，但是我偷懒就先不管了



参数：

- metallic：金属程度
- smoothness：光滑程度。1 - roughness = smoothness



开整：

**1、首先从贴图获得数据，准备好方向数据和需要用的点积结果，以及区分金属和非金属**

~~~c
//1.贴图信息
half4 main_tex = tex2D(_MainTex,i.uv);
half3 normal_data = UnpackNormal(tex2D(_NormalMap,i.uv));
half metallic = tex2D(_MetallicMap,i.uv).r;
half roughness = tex2D(_RoughnessMap,i.uv).r;
half occlusion = tex2D(_OcclusionMap,i.uv).r;

//2.整理信息
half3 albedo = main_tex.rgb  * _Color.rgb;			//反照率
metallic *=  _MetallicStrength;						//金属度
roughness = max( roughness * _Smoothness,0.0001f);	//粗糙度


//3.计算方向
float3 worldPos = float3(i.TtoW0.w,i.TtoW1.w,i.TtoW2.w);//世界坐标

normal_data.xy *= _NormalScale;
normal_data.z = sqrt(1.0 - saturate(dot(normal_data.xy,normal_data.xy)));

//法线方向
half3 normal_dir = normalize(half3(dot(i.TtoW0.xyz,normal_data),
									dot(i.TtoW1.xyz,normal_data),dot(i.TtoW2.xyz,normal_data)));

half3 light_dir = normalize(UnityWorldSpaceLightDir(worldPos));	//世界空间下的灯光方向,定义在UnityCG.cginc
half3 view_dir = normalize(UnityWorldSpaceViewDir(worldPos));	//世界空间下的观察方向,定义在UnityCG.cginc
half3 reflect_dir = reflect(-view_dir,normal_dir);				//世界空间下的反射方向
half3 half_dir = normalize(light_dir + view_dir);

//4.准备数据
//计算BRDF需要用到一些项
half nv = saturate(dot(normal_dir,view_dir));
half nl = saturate(dot(normal_dir,light_dir));
half nh = saturate(dot(normal_dir,half_dir));
half lh = saturate(dot(light_dir,half_dir));
half lv = saturate(dot(light_dir,view_dir));

//5.区分金属与非金属
//计算镜面反射率
half3 specColor = albedo * metallic;
//计算1 - 反射率,漫反射总比率
half oneMinusReflectivity = (1- metallic);
//计算漫反射率
half3 diffColor = albedo * oneMinusReflectivity;
~~~

这部分没什么好说的，主要就是准备数据，区分金属和非金属区域



**2-1.然后开始计算直接光照**

~~~c
//计算BRDF，即直接光
//计算直接光镜面反射
half V = ComputeSmithJointGGXVisibilityTerm(nl,nv,roughness);	//可见性V,该项是自遮挡G项和校正因子
half D = ComputeGGXTerm(nh,roughness);							//法线分布函数D项
half3 F = ComputeFresnelTerm(specColor,lh);						//菲涅尔F项

half3 specularTerm = V * D * F;	//合并

//计算直接光漫反射
half3 diffuseTerm = ComputeDisneyDiffuseTerm(nv,nl,lh,roughness,diffColor);//迪士尼漫反射
~~~

首先从BRDF公式开始

一般我们看到的公式都是根据Cook-Torrance 的微表面高光BRDF公式，如下所示：

![](https://img2018.cnblogs.com/blog/626282/201810/626282-20181018143743732-1214081166.png)

- l：入射光方向
- v：视角方向，即摄像机方向
- h：微表面法线
- n：宏观表面法线

4(n · l)(n · v)为宏观表面和微观表面的校正因子



BRDF是什么：给定l和v，求出**出射光**。即描述表面入射光和反射光关系的

接下来是DFG项分别是干嘛的。公式详细式子请到扩展里

- D项：法线分布函数（Normal Distribution Function，简写为NDF）。向NDF输入**h**，NDF会返回朝向是**h**的微表面数占微表面总数的比例。比如有1%的微表面朝向是**h**，那么就有1%的微表面可能将光线反射到**v**方向。《shader入门精要》里总结：返回有多少**微平面法线m = h** 的比例

  ![](https://pic4.zhimg.com/85e93632f88e18f46cc9b73729c31a93_r.jpg)

- G项：几何函数（Geometry Function）。不是所有微表面都能收到接受到光线，如下面左边的图有一部分入射光和出射光被遮挡住。光线在微表面之间还会互相反射，如下面右边的图，这可能也是一部分漫射光的来源，但实际上这部分光线可以忽略。输入入射和出射光线方向，输出值表示光线未被遮蔽而能从**l**反射到**v**方向的比例

  ![](https://pic4.zhimg.com/bf148ad85915e647cdb50762999da037_r.jpg)

- F项：菲涅尔方程（Fresnel Equations）。光学平面并不会将所有光线都反射掉，而是一部分被反射，一部分被折射

  ![](https://pic4.zhimg.com/v2-ea3437626cba384c3b8a56ab91965a73_r.jpg)



**2-2.知道了理论那就直接开干**

~~~c
//计算Smith-Joint阴影遮掩函数，返回的是除以校正因子的可见性项V
half ComputeSmithJointGGXVisibilityTerm(half nl,half nv,half roughness)
{
	half ag = roughness * roughness;
	half lambdaV = nl * (nv * (1 - ag) + ag);
	half lambdaL = nv * (nl * (1 - ag) + ag);
			
	return 0.5f/(lambdaV + lambdaL + 1e-5f);
}

//计算D项法线分布函数GGX(TrowBridge-Reitz)
half ComputeGGXTerm(half nh,half roughness)
{
	half a = roughness * roughness;
	half a2 = a * a;
	half d = (a2 - 1.0f) * nh * nh + 1.0f;
	//UNITY_INV_PI定义在UnityCG.cginc  为1/π
	return a2 * UNITY_INV_PI / (d * d + 1e-5f);
}

//计算F项菲涅尔反射Schlick近似
//F0:镜面反射所占的比率也就是specColor
half3 ComputeFresnelTerm(half3 F0,half cosA)
{
	return F0 + (1 - F0) * pow(1 - cosA, 5);
}

//计算迪士尼漫反射项
half3 ComputeDisneyDiffuseTerm(half nv,half nl,half lh,half roughness,half3 baseColor)
{
	half Fd90 = 0.5f + 2 * roughness * lh * lh;
	return baseColor * UNITY_INV_PI * (1 + (Fd90 - 1) * pow(1-nl,5)) * (1 + (Fd90 - 1) * pow(1-nv,5));
}
~~~

相应的公式可以看扩展部分

这样一来**直接光**部分就完成了



**3.接下来就是间接光部分**

只有直接光还不够，还需要间接光来润色

待续







最终效果

![](../img/in-post/PBR/PBR1.gif)



## 扩展

1. [DFG公式式子](https://www.cnblogs.com/wbaoqing/p/9810386.html)



## 引用

1. https://zhuanlan.zhihu.com/p/60972473
2. https://zhuanlan.zhihu.com/p/21376124
3. https://www.cnblogs.com/wbaoqing/p/9810386.html
4. https://www.dorian-iten.com/fresnel/

感谢各位大佬的艰苦付出

图文有侵立删


