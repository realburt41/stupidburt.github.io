---
layout:     post
title:      "年轻人第一个PBR（一）"
subtitle:   "造轮子时间！"
date:       2021-7-2
author:     "Burt"
header-style: text 
tags:
    - PBR
    - Shader
---



## 前言

只要是做渲染的，应该没有人没听过pbr吧



## 一、啰哩吧嗦

好处是：

1. 表达能力强(一个shader能通过调节表达过去十几几十个shader的效果)
2. 美术参数减少
3. 参数基于物理，美术程序更好理解
4. 制定统一的美术标准（即标准化）
5. 光照和材质解耦，艺术家可以不用关注贴图上如何呈现光照质感，只专注于材质本身



**实际上的“PB”在实时渲染并不完全是Physically Based**，只是一种近似



PBR材质有两个方面

- 表面：相对容易实现，大部分用于微平面理论和迪士尼BRDF
- 体积：相对更难实现，关注快速、近似的单次散射和多次散射，例如云，皮肤，头发等



这里我们只讲表面



还有关于什么辐射量之类的我实在是看不懂，等以后大佬带带我吧



## 二、PBR核心理论

- 微平面理论：DG项
- 能量守恒：出射光 <= 入射光（自发光除外）。粗糙度相关
- 菲涅尔反射：F项
- 线性空间与伽马矫正
- 色调映射：HDR转LDR，一般在后处理ACES
- 物质的光学特性：金属与非金属



## 三、代码实现

我这次用偷懒版金属流，没有考虑GI，之后会总结高光流和金属流的优缺点（抄就完事了）

首先是PBR框架

- 直接漫反射：迪士尼Burly漫反射
- 直接镜面反射：微表面模型的Cook-Torrance高光模型
- 间接漫反射：光照贴图
- 间接镜面反射：全局反射探针



前两个是光直接照射到产生的颜色

后两个是从别的物体或者环境弹射到产生的颜色，偷懒直接用Unity自带的api



贴图参数则是标配

- albedo贴图
- 法线贴图
- 金属度贴图：区分金属与非金属
- 粗糙度贴图
- AO贴图

其实后三个可以合并成一张图，都是单通道信息，但是我偷懒就先不管了



参数：

- metallic：金属程度
- smoothness：光滑程度。1 - roughness = smoothness



开整：

**1、首先从贴图获得数据，准备好方向数据和需要用的点积结果，以及区分金属和非金属**

~~~c++
//1.贴图信息
half4 main_tex = tex2D(_MainTex,i.uv);
half3 normal_data = UnpackNormal(tex2D(_NormalMap,i.uv));
half metallic = tex2D(_MetallicMap,i.uv).r;
half roughness = tex2D(_RoughnessMap,i.uv).r;
half ao = tex2D(_OcclusionMap,i.uv).r;

//2.整理信息
half3 albedo = main_tex.rgb  * _Color.rgb;			//反照率
metallic *=  _MetallicStrength;						//金属度
roughness = max(roughness * _Smoothness,0.0001f);	//粗糙度


//3.计算方向
float3 pos_world = float3(i.TtoW0.w,i.TtoW1.w,i.TtoW2.w);//世界坐标

normal_data.xy *= _NormalScale;
normal_data.z = sqrt(1.0 - saturate(dot(normal_data.xy,normal_data.xy)));

//法线方向
half3 normal_dir = normalize(half3(dot(i.TtoW0.xyz,normal_data),
									dot(i.TtoW1.xyz,normal_data),dot(i.TtoW2.xyz,normal_data)));

half3 light_dir = normalize(UnityWorldSpaceLightDir(pos_world));	//世界空间下的灯光方向,定义在UnityCG.cginc
half3 view_dir = normalize(UnityWorldSpaceViewDir(pos_world));		//世界空间下的观察方向,定义在UnityCG.cginc
half3 reflect_dir = reflect(-view_dir,normal_dir);					//世界空间下的反射方向
half3 half_dir = normalize(light_dir + view_dir);

//4.准备数据
//计算BRDF需要用到一些项
half nv = saturate(dot(normal_dir,view_dir));
half nl = saturate(dot(normal_dir,light_dir));
half nh = saturate(dot(normal_dir,half_dir));
half lh = saturate(dot(light_dir,half_dir));
half lv = saturate(dot(light_dir,view_dir));

//5.区分金属与非金属
//计算镜面反射率
half3 specColor = albedo * metallic;
//计算1 - 反射率,漫反射总比率
half oneMinusReflectivity = (1- metallic);
//计算漫反射率
half3 diffColor = albedo * oneMinusReflectivity;
~~~

这部分没什么好说的，主要就是准备数据，区分金属和非金属区域



**2-1.然后开始计算直接光照**

~~~c++
//计算BRDF，即直接光
//计算直接光镜面反射
half D = GGXTerm(nh,roughness);							//法线分布函数D项
half3 F = FresnelTerm(specColor,lh);					//菲涅尔F项
half V = SmithJointGGXVisibilityTerm(nl,nv,roughness);	//可见性V,该项是自遮挡G项和校正因子

half3 directSpecular = V * D * F;						//合并

//计算直接光漫反射
half3 directDiffuse = DisneyDiffuse(nv,nl,lh,roughness,diffColor);//迪士尼burly漫反射
~~~

首先从BRDF公式开始

一般我们看到的公式都是根据Cook-Torrance 的微表面高光BRDF公式，如下所示：

![](https://img2018.cnblogs.com/blog/626282/201810/626282-20181018143743732-1214081166.png)

- l：入射光方向
- v：视角方向，即摄像机方向
- h：微表面法线
- n：宏观表面法线

4(n · l)(n · v)为宏观表面和微观表面的校正因子

该方程具有可逆性，即：f(l,v) = f(v,l)



BRDF是什么：给定l和v，求出**出射光**。即描述表面入射光和反射光关系的

接下来是DFG项分别是干嘛的。公式详细式子请到扩展里

- D项：法线分布函数（Normal Distribution Function，简写为NDF）。向NDF输入**h**，NDF会返回朝向是**h**的微表面数占微表面总数的比例。比如有1%的微表面朝向是**h**，那么就有1%的微表面可能将光线反射到**v**方向。《shader入门精要》里总结：返回有多少**微平面法线m = h** 的比例

  ![](https://pic4.zhimg.com/85e93632f88e18f46cc9b73729c31a93_r.jpg)

- G项：几何函数（Geometry Function）。不是所有微表面都能收到接受到光线，如下面左边的图有一部分入射光和出射光被遮挡住，分别叫Shadowing和Masking。光线在微表面之间还会互相反射，如下面右边的图，这可能也是一部分漫射光的来源，但实际上这部分光线可以忽略。G项返回的实际上就是没有被Shadowing和Masking的部分

  ![](https://pic4.zhimg.com/bf148ad85915e647cdb50762999da037_r.jpg)

- F项：菲涅尔方程（Fresnel Equations）。光学平面并不会将所有光线都反射掉，而是一部分被反射，一部分被折射

  ![](https://pic4.zhimg.com/v2-ea3437626cba384c3b8a56ab91965a73_r.jpg)



**2-2.知道了理论那就直接开干**

~~~c++
//计算Smith-Joint阴影遮掩函数，返回的是除以校正因子的可见性项V
half SmithJointGGXVisibilityTerm(half nl,half nv,half roughness)
{
	half ag = roughness * roughness;
	half lambdaV = nl * (nv * (1 - ag) + ag);
	half lambdaL = nv * (nl * (1 - ag) + ag);
			
	return 0.5f/(lambdaV + lambdaL + 1e-5f);
}

//计算D项法线分布函数GGX(TrowBridge-Reitz)
half GGXTerm(half nh,half roughness)
{
	half a = roughness * roughness;
	half a2 = a * a;
	half d = (a2 - 1.0f) * nh * nh + 1.0f;
	//UNITY_INV_PI定义在UnityCG.cginc  为1/π
	return a2 * UNITY_INV_PI / (d * d + 1e-5f);
}

//计算F项菲涅尔反射Schlick近似
//F0:镜面反射所占的比率也就是specColor
half3 FresnelTerm(half3 F0,half cosA)
{
	return F0 + (1 - F0) * pow(1 - cosA, 5);
}

//计算迪士尼漫反射项
half3 DisneyDiffuse(half nv,half nl,half lh,half roughness,half3 baseColor)
{
	half Fd90 = 0.5f + 2 * roughness * lh * lh;
	return baseColor * UNITY_INV_PI * (1 + (Fd90 - 1) * pow(1-nl,5)) * (1 + (Fd90 - 1) * pow(1-nv,5));
}
~~~

相应的公式可以看扩展部分

这样一来**直接光**部分就完成了



**3.接下来就是间接光部分**

只有直接光还不够，还需要间接光来润色

间接光，Unity里的做法是用GI，这里我用的球谐函数和全局反射探针

~~~c++
//4.计算间接光
//计算间接光漫反射
half3 indirectDiffuse =  ShadeSH9(half4(normal_dir,1)) * ao * diffColor;

//计算间接镜面反射
half3 indirectSpecular = IndirectSpecular(reflect_dir,pos_world,roughness,ao);
//计算掠射角时反射率
half grazingTerm = saturate(roughness + (1-oneMinusReflectivity));
indirectSpecular *= FresnelLerp(specColor,grazingTerm,nv);
~~~

间接漫反射用的是Unity内置自带的球谐函数

也可以用以下方法来得到一样的的效果

~~~c++
float3 custom_sh(float3 normal_dir)
{
    float4 normalForSH = float4(normal_dir,1.0);

    //SHEvalLinearL0L1
    half3 x;
    x.r = dot(custom_SHAr,normalForSH);
    x.g = dot(custom_SHAg,normalForSH);
    x.b = dot(custom_SHAb,normalForSH);

    //SHEvalLinearL2
    half3 x1,x2;
    //4 of the quadratic(L2) polynomial
    half4 vB = normalForSH.xyzz * normalForSH.yzzx;
    x1.r = dot(custom_SHBr,vB);
    x1.g = dot(custom_SHBg,vB);
    x1.b = dot(custom_SHBb,vB);

    //Final (5th) quadratic (L2) polynomial
    half vC = normalForSH.x * normalForSH.x - normalForSH.y * normalForSH.y;
    x2 = custom_SHC.rgb * vC;

    float3 sh = max(float3(0,0,0),(x + x1 + x2));
    sh = pow(sh,1.0 / 2.2);

    return sh;
}
~~~

只不过上述的系数需要通过插件预先算好CubeMap的球谐系数然后传进来

这里偷懒直接用Unity的api

间接直接光就做好了

间接镜面反射是抄一个[大佬](https://zhuanlan.zhihu.com/p/60972473)的思路（代码）

使用Unity的全局反射探针，但是不能直接拿来用，需要对其重新映射反射方向

~~~c++
//计算间接光镜面反射
half3 IndirectSpecular(half3 reflect_dir,float3 pos_world,half roughness,half ao)
{
	half3 specular = 0;
	//重新映射第一个反射探头的采样方向
	half3 refDir1 = BoxProjectedDirection(reflect_dir,pos_world,unity_SpecCube0_ProbePosition,unity_SpecCube0_BoxMin,unity_SpecCube0_BoxMax);
	//对第一个反射探头进行采样
	half3 ref1 = SamplerReflectProbe(UNITY_PASS_TEXCUBE(unity_SpecCube0),refDir1,roughness,unity_SpecCube0_HDR);
	//如果第一个反射探头的权重小于1的话，我们将会采样第二个反射探头，进行混合
	//使下面的if语句产生分支，定义在HLSLSupport.cginc中
	UNITY_BRANCH
	if(unity_SpecCube0_BoxMin.w < 0.99999)
	{
		//重新映射第二个反射探头的方向
		half3 refDir2 = BoxProjectedDirection(reflect_dir,pos_world,unity_SpecCube1_ProbePosition,unity_SpecCube1_BoxMin,unity_SpecCube1_BoxMax);
		//对第二个反射探头进行采样
		half3 ref2 = SamplerReflectProbe(UNITY_PASS_TEXCUBE_SAMPLER(unity_SpecCube1,unity_SpecCube0),refDir2,roughness,unity_SpecCube1_HDR);

		//进行混合
		specular = lerp(ref2,ref1,unity_SpecCube0_BoxMin.w);
	}
	else
	{
		specular = ref1;
	}
	return specular * ao;
}

//重新映射反射方向
half3 BoxProjectedDirection(half3 worldRefDir,float3 pos_world,float4 cubemapCenter,float4 boxMin,float4 boxMax)
{
	//使下面的if语句产生分支，定义在HLSLSupport.cginc中
	UNITY_BRANCH
	if(cubemapCenter.w > 0.0)//如果反射探头开启了BoxProjection选项，cubemapCenter.w > 0
	{
		half3 rbmax = (boxMax.xyz - pos_world) / worldRefDir;
		half3 rbmin = (boxMin.xyz - pos_world) / worldRefDir;

		half3 rbminmax = (worldRefDir > 0.0f) ? rbmax : rbmin;

		half fa = min(min(rbminmax.x,rbminmax.y),rbminmax.z);

		pos_world -= cubemapCenter.xyz;
		worldRefDir = pos_world + worldRefDir * fa;
	}
	return worldRefDir;
}

//采样反射探针
//UNITY_ARGS_TEXCUBE定义在HLSLSupport.cginc,用来区别平台
half3 SamplerReflectProbe(UNITY_ARGS_TEXCUBE(tex),half3 reflect_dir,half roughness,half4 hdr)
{
	roughness = roughness * (1.7 - 0.7 * roughness);
	half mip = roughness * 6;
	//对反射探头进行采样
	//UNITY_SAMPLE_TEXCUBE_LOD定义在HLSLSupport.cginc，用来区别平台
	half4 rgbm = UNITY_SAMPLE_TEXCUBE_LOD(tex,reflect_dir,mip);
	//采样后的结果包含HDR,所以我们需要将结果转换到RGB
	//定义在UnityCG.cginc
	return DecodeHDR(rgbm,hdr);
}
~~~



**3.全部都计算完了，可以合并了！**

~~~c++
//4.计算最后的颜色
half3 color = half3(0,0,0);

color += UNITY_PI * (directDiffuse + directSpecular) * _LightColor0.rgb * nl * atten;
color += indirectDiffuse + indirectSpecular;
color = saturate(color);
~~~

关于第二句代码

- PI是为了和直接光两个反PI对冲，也有提亮的作用
- atten是阴影系数



**4.最终效果**

![](https://raw.githubusercontent.com/realburt41/realburt41.github.io/master/img/in-post/PBR/PBR1.png)



## 扩展

1. [DFG公式式子](https://www.cnblogs.com/wbaoqing/p/9810386.html)



## 引用

1. https://zhuanlan.zhihu.com/p/60972473
2. https://zhuanlan.zhihu.com/p/21376124
3. https://www.cnblogs.com/wbaoqing/p/9810386.html
4. https://www.dorian-iten.com/fresnel/

感谢各位大佬的艰苦付出

图文有侵立删


